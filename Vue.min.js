const isFunction = (/** @type {any} */ target ) => target instanceof Function;
const isObject = (/** @type {any} */ target ) => target instanceof Object;
const isArray = Array.isArray;
const isNotObject = (/** @type {any} */ target ) => !isObject( target ) && isNotArray( target );
const isNotArray = (/** @type {any} */ target ) => !isArray( target );
const isString = (/** @type {any} */ target ) => typeof target === "string";
const isNotString = (/** @type {any} */ target ) => !isString( target );
const isNull = (/** @type {any} */ target ) =>
    target === ( void 0 ) || target === null || target === undefined;
const isNotNull = (/** @type {any} */ target ) => !isNull( target );
const isMustache = value =>
{
    return /{{(.+?)}}/gi.test( value ) || /\${(.+?)}/gi.test( value );
};

function deepClone ( target )
{
    if ( isNull( target ) )
    {
        console.warn( "target is null" );
    }
    if ( isNotObject( target ) || isFunction( target ) )
    {
        return target;
    }
    if ( isArray( target ) )
    {
        const clone = [];
        Array.from( target ).forEach( r =>
        {
            clone.push( deepClone( r ) );
        } );
        return clone;
    } else
    {
        const clone = {};
        const keys = Reflect.ownKeys( target );
        keys.forEach( key =>
        {
            Reflect.set( clone, key, deepClone(
                Reflect.get( target, key, target )
            ), clone );
        } );
        return clone;
    }

}

function timer ( fn, text )
{
  console.time( text );
  fn();
  console.timeEnd( text
  );
}

/**
 * @param {any} target
 */
function ƒ(target) {
    return new Proxy(target, {
        set(target, key, value, receiver) {
            if (target[key] === value) {
                return true;
            } else {
                const result = Reflect.set(target, key, value, receiver);
                Vue.dept.notifyAll();
                return result;
            }
        }
    });
}


function createProxy(target) {
    if (isNotObject(target)) {
        console.warn(`${target} is not a Object!`);
        return undefined;
    }
    for (const key of Object.keys(target)) {
        if (isObject(target[key])) {
            target[key] = createProxy(target[key]);
        }
    }
    return ƒ(target);
}

const get = ( target, key, receiver ) => Reflect.get( target, key, receiver );
const set = ( target, key, value, receiver ) =>
{
    if ( !has( target, key ) ) return true;
    if ( get( target, key, receiver ) )
    {
        return true;
    } else
    {
        Reflect.set( target, key, value, receiver );
    }
};
const has = ( target, key ) => Reflect.has( target, key );

/**
 *
 * @param {Object}target
 * @return Object
 */
function readonly ( target )
{
    if ( !isObject( target ) )
    {
        console.warn( `${ target } is not a Object!` );
        return target;
    }
    return new Proxy( target, {
        get,
        set,
        has,
    } );
}


/**
 *
 * @param {Object}target
 * @return Object
 */
function deepReadOnly ( target )
{
    if ( !isObject( target ) )
    {
        console.warn( `${ target } is not a Object!` );
        return target;
    }
    for ( const key of Object.keys( target ) )
    {
        if ( isObject( target[ key ] ) )
        {
            target[ key ] = deepReadOnly( target[ key ] );
        }
    }
    return readonly( target );
}

class Dept {
    #value = [];

    /**
     * @param {any} context
     */
    $emit(context) {
        this.#value.push(context);
    }

    notifyAll() {
        this.#value.forEach(e => e.update());
    }
}

const dept = new Dept();

// @ts-nocheck

class Node
{
    /**
     * @type {boolean}
     */
    isStatic;
    /**
     * @type {Node}
     */
    parent;
    /**
     * @type {HTMLElement}
     */
    elm;

    get static ()
    {
        return this.isStatic;
    }

    set static ( value )
    {
        this.isStatic = value;
    }

    init ()
    {
        return document.createElement( "" );
    }

    /**
     *
     * @param {Node} target
     * @returns
     */
    isInstance ( target )
    {
        // @ts-ignore
        return ( ( this instanceof TNode && target instanceof TNode ) || ( this instanceof ENode && target instanceof ENode ) );
    }

    /**
     * 复制本身
     */
    /**
     * @returns{ENode|TNode}
     */
    clone ()
    {
    }

}

//Todo 类型会被转换为string 使用模版解析时

/**
 * @param {string} stencil
 * @param {any} view
 */
function mustache ( stencil, view )
{
    return render( ProcessingText( stencil ), view );

}

/**
 * @param {string} stencil
 * @param {any} view
 * @returns {string|boolean|Function|object}
 */
function propsMustache ( stencil, view )
{
    return isMustache( stencil ) ? mustache( stencil, view ) : render( stencil, view );
}

/**
 * @param {string} text
 * @returns {string}
 */
function ProcessingText ( text )
{
    const stencilRegexp = /{{(.+?)}}|\${(.+?)}/g;
    let match;
    let stencil = [];
    let index = 0;
    if ( ( match = stencilRegexp.exec( text ) ) !== null )
    {
        do
        {
            // s l
            let lastIndex = stencilRegexp.lastIndex;
            if ( match.index > index )
            {
                stencil.push( `\`${ text.slice( index, match.index ) }\`` );
            }
            stencil.push( `(${ match[ 1 ] ?? match[ 2 ] })` );
            index = lastIndex;
        } while ( ( match = stencilRegexp.exec( text ) ) !== null );
        if ( index < text.length )
        {
            stencil.push( `\`${ text.slice( index, text.length ) }\`` );
        }
        return stencil.join( "+" );
    } else return text;
}

const render = ( /** @type {string} */ stencil, target) => {
    const template = `with(this){  return ${stencil}}`;
    try {
        let parseResults = new Function(template).call(target);
        if (isNull(parseResults)) {
            return stencil;
        }
        return parseResults;
    } catch (e) {
        return stencil;
    }
};

// @ts-nocheck

class TNode extends Node {
    text;
    isStatic = true;
    /**
     @type{Text}
     */
        // @ts-ignore
    elm;

    /**
     * 仅仅做没有else 的处理 if
     */
    key;

    /**
     */
    constructor(text) {
        super();
        this.text = text;
        this.key = this.text.length << 5;
    }

    /**
     * @param {any} context
     */
    render(context) {
        this.text = mustache(this.text, context instanceof Vue ? context._data : context);
    }

    /**
     *
     * @return {Text}
     */
    init() {
        // @ts-ignore
        return this.elm = document.createTextNode(this.text);
    }

    clone() {
        return Object.create({
            __proto__: TNode.prototype, text: this.text, isStatic: this.static
        });
    }

    /**
     * @param {Node | import("./ENode.js").default} other
     */
    equal(other) {
        return this.key === other.key && this.isInstance(other) && this.text === other.text;
    }

}

/**
 * @author 陈浩
 * @date 2022-01-16 20:22:42
 * @slogan: Talk is cheap. Show me the code.
 * @Last Modified by: 陈浩
 * @Last Modified time: 2022-01-29 07:04:52
 */

class ENode extends Node {
    /**
     * @type {HTMLElement}
     */
    elm;
    /**
     * @type {number | undefined}
     */
    key;
    /**
     * @type {string}
     */
    sel;
    attributes = {};
    props = {
        attributes: {},
        method: {},
    };
    $props = {
        attributes: {},
        method: {},
    };
    children;

    /**
     * @param {String} sel
     * @param {{ [s: string]: Attr; } | ArrayLike<Attr>|Object} attributes
     * @param {Array<Node>} children
     */
    constructor(sel, attributes, children) {
        super();
        this.sel = sel;
        this.setAttributes = attributes;
        this.children = children;
        this.children.forEach((e) => (e.parent = this));
    }

    get prop() {
        return this.$props;
    }

    // @ts-ignore
    /**
     * @param {{ [s: string]: Attr; } | ArrayLike<Attr>} attr
     */
    set setAttributes(attr) {
        for (const [name, value] of Object.entries(attr)) {
            switch (true) {
                case /v-bind:/gi.test(name): {
                    Reflect.set(
                        this.$props.attributes,
                        name.slice(7),
                        // @ts-ignore
                        value.trim(),
                        this.$props.attributes,
                    );
                }
                    break;
                case /@click/gi.test(name): {
                    Reflect.set(
                        this.$props.method,
                        "click",
                        // @ts-ignore
                        value.trim(),
                        this.$props.method,
                    );
                }
                    break;
                case /@for/gi.test(name): {
                    // @ts-ignore
                    this.dynamicTemplate = value;
                }
                    break;
                case /@if|@else|@show|:key|@else-if|@/gi.test(name):
                    // @ts-ignore
                    this.$props.attributes[name.slice(1)] = value.trim();
                    break;
                default:
                    // @ts-ignore
                    Reflect.set(this.attributes, name, value.trim(), this.attributes);
            }
        }
    }

    /**
     * @param {object} context
     */
    render(context) {
        for (const [key, value] of Object.entries(this.$props.attributes)) {
            switch (key) {
                case "show": {
                    const isShow = propsMustache(value, context._data);
                    if (isShow === false || isShow === "0") {
                        /**
                         * 含有某些属性，开启缓存,且用户本身含有属性
                         */
                        if (isNotNull(this.attributes["display"])) {
                            //Todo 没有缓冲，开启缓存,后面如果需要，则需要具体判断key缓存是否存在
                            if (isNull(this.$props.cache)) {
                                this.$props.cache = {
                                    show: this.attributes["display"],
                                };
                            } else if (isNull(this.$props.cache["show"]))
                                this.$props.cache["show"] = this.attributes["display"];
                        }
                        this.props.attributes["display"] = "none";
                    } else {
                        if (isNull(this.$props.cache) || isNull(this.$props.cache.show)) {
                            this.props.attributes["display"] = "block";
                        } else {
                            this.props.attributes["display"] = this.$props.cache.show;
                        }
                    }
                    break;
                }
                case "key":
                    break;
                default: {
                    this.props.attributes[key] = propsMustache(value,
                        context._data
                    );
                }
            }
        }
        for (const [key, value] of Object.entries(this.$props.method)) {
            if (isNotNull(this.props.method[key])) {
                continue;
            }
            const methodRegExp =
                /(?<name>\w+)?([(,])(?<arg>.*?)(?=[,)])/g;
            let result = methodRegExp.exec(value);
            let name, args = [];
            do {
                // @ts-ignore
                const {groups: {name: N, arg} = {name: undefined}} = result;
                if (N) {
                    name = N;
                }
                if (arg && arg !== '') {
                    args.push(arg);
                }
            } while ((result = methodRegExp.exec(value)) !== null);
            const fun = propsMustache(
                name,
                {
                    ...context
                    , ...context._methods
                }
            );
            this.props.method[key] = () => {
                const _args = [];
                Array.from(args).forEach((arg) => {
                    _args.push(
                        propsMustache(
                            arg, {
                                ...context,
                                ...context._data,
                            }
                        ),
                    );
                });
                fun.apply(context, _args);
            };
        }
        // @ts-ignore
    }

    init() {
        let dom = document.createElement(this.sel);
        for (const [key, value] of Object.entries(Object.assign(this.attributes, this.props.attributes))) {
            setAttribute(dom, key, value);
        }
        for (const [/**@type{HTMLElementEventMap}*/key, value] of Object.entries(this.props.method)) {
            dispatchEvent(dom, key, value);
        }
        // @ts-ignore
        const fam = document.createDocumentFragment();
        this.children.forEach(child => fam.appendChild(child.init()));
        dom.appendChild(fam);
        this.elm = dom;
        return dom;
    }

    /**
     *
     * @param {ENode|TNode} other
     * @returns {boolean}
     */
    equal(other) {
        // @ts-ignore
        return (
            // @ts-ignore
            this.key === other.key && this.isInstance(other) && other.sel === this.sel
        );
    }

    clone() {
        const cloneChild = [];
        this.children.forEach((e) => {
            cloneChild.push(e.clone());
        });
        const clone = Object.create({
            __proto__: ENode.prototype,
            sel: this.sel,
            children: cloneChild,
            $props: this.$props,
            props: deepClone(this.props),
            attributes: this.attributes,
            isStatic: this.static,
            key: this.key,
            dynamicTemplate: this.dynamicTemplate
        });
        clone.children.forEach((/** @type {{ parent: ENode; }} */ child) => child.parent = clone);
        return clone;
    }
}

/**
 * @param {string} tagName
 * @param {NamedNodeMap | null} attributes
 * @param {NodeListOf<ChildNode> | null} children
 */
function h ( tagName, attributes, children )
{
    if ( attributes === null && children === null ) {
        return `_t(${ JSON.stringify( tagName ) })`;
    }
    const childrenNodes = new Array( 0 );
    // @ts-ignore
    for ( const child of children ) {
        if ( child instanceof HTMLElement ) {
            childrenNodes.push( h( child.tagName, child.attributes, child.childNodes ) );
        } else if ( child instanceof Comment ) ; else {
            // @ts-ignore
            childrenNodes.push( h( child.textContent, null, null ) );
        }
    }
    return `_c(${ JSON.stringify( tagName ) },${ stringify( attributes ) }, [ ${ childrenNodes } ] )`
}
function stringify ( attributes )
{
    const attr = {};
    for ( const [ _, { name, value } ] of Object.entries( attributes ) ) {
        attr[ name ] = value;
    }    return JSON.stringify( attr );
}

const forRegExp = /(?<head>\(.*\)|\w+)\s+(?<body>in|of)\s+(?<target>.*)/;
const aliasExp = /(?<=[(|,]).*?(?=[,|)])/gi;
/**
 *
 * @param {Object} arg0 视图数据
 * @returns 动态子节点
 */
const forDynamicGeneration = ({
                                  context,
                                  node: {children: templateChildren},
                                  attrElement,
                                  attrElement2
                              }) => {
    const forModel = {};
    const foredeck = forRegExp.exec(attrElement);
    // @ts-ignore
    const head = foredeck.groups["head"];
    // @ts-ignore
    foredeck.groups["body"];
    let global, view;
    if (context instanceof Vue) {
        global = context;
        view = context._data;
    } else {
        global = context.global;
        view = context;
    }
    // @ts-ignore
    const target = propsMustache(foredeck.groups["target"], view);
    forModel["target"] = target;
    const headers = head.match(aliasExp);
    if (isNull(headers)) {
        forModel["itemKey"] = head;
    } else {
        // @ts-ignore
        forModel["itemKey"] = headers[0];
        // @ts-ignore
        if (headers.length === 2) {
            // @ts-ignore
            forModel["indexKey"] = headers[1];
        } else {
            // @ts-ignore
            forModel["nameKey"] = headers[1];
            // @ts-ignore
            forModel["indexKey"] = headers[2];
        }
    }
    const newChildren = [];
    let index = 0;
    if (isArray(target)) {
        for (const convex of target) {
            for (const child of templateChildren) {
                let clone = child.clone();
                const _context = {
                    [forModel["itemKey"]]: convex, [forModel["indexKey"]]: index, ["global"]: global
                };
                clone.key = propsMustache(attrElement2, _context);
                compile(clone, _context, index);
                newChildren.push(clone);
            }
            index++;
        }
    } else if (isObject(target)) {
        for (const ownKey of Reflect.ownKeys(target)) {
            const value = Reflect.get(target, ownKey, target);
            for (const child of templateChildren) {
                let clone = child.clone();
                clone.key = value[attrElement2];
                compile(clone, {
                    [forModel["itemKey"]]: value,
                    [forModel["nameKey"]]: ownKey,
                    [forModel["indexKey"]]: index,
                    ["global"]: global
                }, index);
                newChildren.push(clone);
            }
            index++;
        }
    }
    return newChildren;
};


/**
 * @param {ENode | TNode} node
 * @param {any } context
 * @param index
 */
function compile(node, context, index = 1) {
    if (node instanceof ENode) {
        // @ts-ignore
        node.static = !(Reflect.ownKeys(node.prop.attributes).length > 0 || Reflect.ownKeys(node.prop.method).length > 0);
        //通过节点属性生成key +index
        //设置flag 当是for 信息时，子节点不需要递归编译
        let flag = true;
        if (isNotNull(node.dynamicTemplate)) {
            // @ts-ignore
            node.children = forDynamicGeneration({
                context: context,
                node: node,
                attrElement: node.dynamicTemplate,
                attrElement2: node.prop.attributes["key"]
            });
            flag = false;
        }
        node.key = node.key ?? calculateCode(node, index);
        //更新视图内容
        node.render(context);
        //处理子节点的if-else-if -else
        const watcher = ifProcessor(node.children);
        /**
         * 取出消息
         */
        if (!watcher.$empty()) {
            watcher.$on(node, context["_data"]);
        }
        if (flag) {
            // @ts-ignore
            node.children.forEach((child, index) => compile(child, context, index));
        }
    } else {
        //@ts-ignore
        const tem = node.text;
        node["static"] = !isMustache(tem);
        if (!(node["static"] = !isMustache(tem))) node.render(context);
    }
}


/**
 * @param {ENode} node
 * @param {number} index
 */
function calculateCode(node, index) {
    return (index << 5) + ((Object.keys(node?.attributes ?? {}).length + 9) << 2) + ((Object.keys(node.prop.attributes).length + 8) << 3) + ((Object.keys(node.prop.method).length + 9) << 4);
}

class Observer {
    /**
     *@type{Array<{index:number,attr:{}}>}
     */
    message = [];

    /**
     * @param {ENode} node
     * @param {any} context
     */
    $on(node, context) {
        const msg = this.message.shift();
        let index = 0;
        if (isNull(msg?.attr["if"])) {
            console.warn(`The if node should be defined first`);
            // @ts-ignore
            this.message.unshift(msg);
        } else {
            const res = propsMustache(msg?.attr["if"], context);
            if (res) {
                this.$destroy(node, 0);
                return;
            } else {
                // @ts-ignore
                node.children.splice(msg?.index + index--, 1);
            }
        }
        while (this.message.length > 0) {
            const res = this.message.shift() ?? {
                attr: "", index: -1
            };
            if (isNotNull(res?.attr["else-if"])) {
                if (propsMustache(res?.attr["else-if"], context)) {
                    break;
                } else {
                    node.children.splice(res.index + index--, 1);
                }
            } else if (isNotNull(res?.attr["else"])) {
                if (index === 0) {
                    console.warn("Else tag should not be in the first place, if it is in the first place it will never show!");
                    node.children.splice(res.index + index--, 1);
                    continue;
                }
                if (this.message.length !== 0) {
                    console.warn("Else tag is not last or multiple");
                    // Wipe the user's ass
                    node.children.splice(res.index + index--, 1);
                }
            } else {
                console.warn(`The label ${JSON.stringify(res?.attr)} should not appear here`);
                // Wipe the user's ass
                node.children.splice(res.index + index--, 1);
            }
        }
        this.$destroy(node, index);
    }

    /**
     * @param {ENode} node
     * @param {number} index
     */
    $destroy(node, index) {
        while (this.message.length > 0) {
            const res = this.message.shift();
            // @ts-ignore
            node.children.splice(res?.index + index--, 1);
        }
    }

    /**
     * @param {{ index: number;  attr: any; }} message
     */
    $emit(message) {
        this.message.push(message);
    }

    $empty() {
        return this.message.length === 0;
    }

}

const watcher = new Observer();

/**
 * @param {string | any[]} children
 */
function ifProcessor(children) {
    for (let index = 0; index < children.length; index++) {
        const child = children[index];
        if (isNotNull(child.prop?.attributes["if"])) {
            watcher.$emit({
                index, attr: {
                    "if": child.prop.attributes["if"]
                }
            });
        } else if (isNotNull(child.prop?.attributes["else-if"])) {
            watcher.$emit({
                index, attr: {
                    "else-if": child.prop.attributes["else-if"]
                }
            });
        } else if (isNotNull(child.prop?.attributes["else"])) {
            watcher.$emit({
                index, attr: {
                    "else": child.prop.attributes["else"]
                }
            });
        }
    }
    return watcher;
}

/**
 * @param {HTMLElement} elm
 * @param {DocumentFragment} newElm
 * @param {HTMLElement} oldElm
 */
function insertBefore(elm, newElm, oldElm) {
    elm.insertBefore(newElm, oldElm);
}

/**
 * @param {{ isInstance: (arg0: any) => any; equal: (arg0: any) => any; }} node1
 * @param {any} node2
 */
function same ( node1, node2 )
{
    return node1.isInstance( node2 ) && node1.equal( node2 );
}

/**
 * @param {HTMLElement} parenElm
 * @param { Array<ENode|TNode>} oldNode
 * @param { any[]} newNode
 */
function diff ( parenElm, oldNode, newNode )
{
    let oldStartIndex = 0;
    let oldEndIndex = oldNode.length - 1;
    let newStartIndex = 0;
    let newEndIndex = newNode.length - 1;
    let oldStart = oldNode[ oldStartIndex ];
    let oldEnd = oldNode[ oldEndIndex ];
    let newStart = newNode[ newStartIndex ];
    let newEnd = newNode[ newEndIndex ];
    while ( oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex )
    {
        if ( isNull( oldStart ) )
        {
            oldStart = oldNode[ ++oldStartIndex ];
        } else if ( isNull( oldEnd ) )
        {
            oldEnd = oldNode[ --oldEndIndex ];
        } else if ( same( oldStart, newStart ) )
        {
            patchNode( oldStart, newStart );
            oldStart = oldNode[ ++oldStartIndex ];
            newStart = newNode[ ++newStartIndex ];
        } else if ( same( oldEnd, newEnd ) )
        {
            patchNode( oldEnd, newEnd );
            oldEnd = oldNode[ --oldEndIndex ];
            newEnd = newNode[ --newEndIndex ];
        } else if ( same( oldStart, newEnd ) )
        {
            patchNode( oldStart, newEnd );
            // @ts-ignore
            insertBefore( parenElm, oldStart.elm, oldEnd.elm.nextSibling );
            oldStart = oldNode[ ++oldStartIndex ];
            newEnd = newNode[ --newEndIndex ];
        } else if ( same( oldEnd, newStart ) )
        {
            patchNode( oldEnd, newStart );
            // @ts-ignore
            insertBefore( parenElm, oldEnd.elm, oldStart.elm );
            oldEnd = oldNode[ --oldEndIndex ];
            newStart = newNode[ ++newStartIndex ];
        } else
        {
            let os = oldStartIndex;
            let od = oldEndIndex;
            while ( ++os <= od )
            {
                if ( isNotNull( oldNode[ os ] ) && same( oldNode[ os ], newStart ) )
                {
                    break;
                }
            }
            if ( os > od )
            {
                //创建
                const elm = newStart.init();
                // @ts-ignore
                insertBefore( parenElm, elm, oldStart.elm );
            } else
            {
                patchNode( oldNode[ os ], newStart );
                // @ts-ignore
                insertBefore( parenElm, newStart.elm, oldStart.elm );
                // @ts-ignore
                oldNode[ os ] = undefined;
            }
            newStart = newNode[ ++newStartIndex ];
        }
    }
    if ( oldStartIndex > oldEndIndex )
    {
        var fam = document.createDocumentFragment();
        for ( let i = newStartIndex; i <= newEndIndex; i++ )
        {
            fam.appendChild( newNode[ i ].init() );
        }
        insertBefore( parenElm, fam, newNode[ newStartIndex - 1 ].elm.nextSibling );

    } else
    {
        for ( let i = oldStartIndex; i <= oldEndIndex; i++ )
        {
            if ( oldNode[ i ] )
                parenElm.removeChild( oldNode[ i ].elm );
        }
    }
}

/**
 * @param {ENode | TNode} oldNode
 * @param {ENode | TNode} newNode
 */
function patchNode ( oldNode, newNode )
{
    if ( oldNode === newNode ) return;
    const elm = newNode.elm = oldNode.elm;
    if ( newNode instanceof ENode )
    {
        if ( newNode.static )
        ; else {
            // @ts-ignore
            const {attributes: oldAttr} = oldNode.props;
            const {attributes: newAttr} = newNode.props;
            const oldKeys = Object.keys(oldAttr);
            const newKeys = Object.keys(newAttr);
            //去交集更新+新数组差集
            oldKeys.filter(ok => newKeys.includes(ok)).concat(
                ...newKeys.filter(nK => !oldKeys.includes(nK))
            ).forEach(uk => {
                setAttribute(elm, uk, newAttr[uk], oldAttr[uk]);
            });
            //去差集删除
            oldKeys.filter(fk => !newKeys.includes(fk)).forEach(
                dk => {
                    removeAttribute(elm, oldAttr[dk]);
                }
            );
            // 更新完毕
        }
        //@ts-ignore
        //更新children
        if ( newNode.children.length > 0 )
            //@ts-ignore
            if ( oldNode.children.length > 0 )
                //@ts-ignore
                diff( elm, oldNode.children, newNode.children );
            else
            {
                const fam = document.createDocumentFragment();
                newNode.children.forEach( child =>
                {
                    //@ts-ignore
                    fam.appendChild( child.init() );
                } );
                elm.appendChild( fam );
            }
        //@ts-ignore
        else if ( oldNode.children.length > 0 ) {
            // @ts-ignore
            elm.innerHTML = "";
        }
    } else
    {
        // @ts-ignore
        if ( oldNode.text !== newNode.text )
        {
            // @ts-ignore
            elm.innerText = newNode.text;
        }
    }

}

const styleKeys = Object.keys(document.documentElement.style);

function setAttribute(elm, name, value) {
    if (styleKeys.includes(name)) {
        elm.style[name] = value;
    } else if (name === "class") {
        if (arguments[3] !== undefined) {
            let oldV = arguments[3].split(" ");
            const newValues = value.split(" ");
            const newAdd = newValues.filter(r => !oldV.includes(r));
            elm.classList.remove(...oldV.filter(r => !newValues.includes(r)));
            elm.classList.add(...newAdd);
        } else elm.classList.add(...value.split(" "));
    } else if (name === "if" || name === "else-if" || name === "else" || name === "key") ; else {
        elm.setAttribute(name, value);
    }
}

function removeAttribute(elm, name, value) {
    if (styleKeys.includes(name)) {
        elm.style[name] = "";
    } else if (name === "class") {
        elm.classList.remove(...value.split(" "));
    } else if (name === "if" || name === "else-if" || name === "else") ; else {
        elm.removeAttribute(name, value);
    }
}

/**
 * @param {HTMLElement} elm
 * @param {string} name
 * @param {Function} fn
 */
function dispatchEvent(elm, name, fn) {
    // @ts-ignore
    elm.addEventListener(name, fn);
}

/**
 * @author 陈浩
 * @date 2022-01-22 21:55:18
 * @slogan: Talk is cheap. Show me the code.
 * @Last Modified by: 陈浩
 * @Last Modified time: 2022-01-27 08:17:59
 */

const emptyObject = Object.freeze({});

/**
 * @param {Vue} properties
 */
function mount(properties) {
    // @ts-ignore
    properties.reactive = function ( /** @type {any} */ target) {
        return createProxy(target);
    };
    // @ts-ignore
    properties.ref = function ( /** @type {any} */ target) {
        return createProxy(target);
    };
    // @ts-ignore
    properties.readonly = readonly;
    // @ts-ignore
    properties.deepReadOnly = deepReadOnly;
    /**
     * 初始化Options属性
     * @param {Object} Options
     */
    // @ts-ignore
    properties.initialization = function (Options) {
        const keys = Object.keys(Options);
        for (const key of keys) {
            switch (key) {
                case "data": {
                    if (isFunction(Options[key])) {
                        this._data = Options[key].call(this, this);
                    } else {
                        console.warn("data is preferably a function");
                        this._data = Options[key];
                    }
                }
                    break;
                case "create": {
                    if (isFunction(Options[key])) this._create = Options[key];
                }
                    break;
                case "methods": {
                    this._methods = Options[key];
                }
                    break;
                case "mounted": {
                    if (isFunction(Options[key])) this._mounted = Options[key];
                }
                    break;
            }
        }
    };
    /**
     * 挂载节点
     * @param {string} el 节点信息
     * @param context
     */
    // @ts-ignore
    properties.mount = function (el, /**@type{ProxyHandler<Vue>}*/context) {
        if (isNotString(el)) {
            console.warn("el is not specification");
        }
        const dom = document.querySelector(el);
        if (dom === null) {
            console.warn("no node");
            return;
        }
        // console.log(dom.outerHTML)
        // htmlReader(dom.outerHTML)
        this[AST] = new Function("target", `with(target){return ${h(dom.tagName, dom.attributes, dom.childNodes)}}`);
        this.virtualDom = this[AST](context);
        compile(this.virtualDom, context);
        dom.parentElement?.replaceChild(this.virtualDom.init(), dom);
    };
    /**
     * 收集更新信息，进行更新
     */
    // @ts-ignore
    properties.useTask = false;
    // @ts-ignore
    properties.task = [];
    // @ts-ignore
    properties.update = function () {
        // @ts-ignore
        this.task.push(this);
        if (this.useTask === false) {
            //@ts-ignore
            this.useTask = true;
            Promise.resolve().then(timer.bind(null, callback.bind(this), "View update time"));
        }
    };

    function callback() {
        // @ts-ignore
        this.task.length = 0;
        // @ts-ignore
        const oldNode = this.virtualDom;
        // @ts-ignore
        this.virtualDom = this[AST](this);
        // @ts-ignore
        compile(this.virtualDom, this);
        // @ts-ignore
        patchNode(oldNode, this.virtualDom);
        // @ts-ignore
        if (this.task.length > 0) {
            callback.apply(this);
        } else {
            this.useTask = false;
        }
    }

    // @ts-ignore
    properties._c = function ( /** @type {string} */ sel, /** @type {any} */ attributes, /** @type {import("../VirtualDom2/Node.js").default[]} */ children) {
        return new ENode(sel, attributes, children)
    };
    // @ts-ignore
    properties._t = function ( /** @type {any} */ text) {
        return new TNode(text);
    };
}

/**
 * create:视图未更新时调用
 * mounted:视图已经加载完毕使用，建议初始化数据在create中使用
 */
const AST = Symbol("AST");

class Vue {
    static dept = dept;
    static id = 0;
    /**
     *@type{Function}
     */
    [AST];
    _data = emptyObject;
    _methods = emptyObject;
    _create = undefined;
    _mounted = undefined;
    uid;

    /**
     * @param {{ el: any; }} options
     */
    constructor(options) {
        this.uid = Vue.id++;
        //读取属性
        // @ts-ignore
        this.initialization(options);
        const context = new Proxy(this, {
            get(target, key, receiver) {
                return (Reflect.get(target, key, receiver) ?? Reflect.get(target._data, key, target._data) ?? Reflect.get(target._methods, key, target._methods));
            }, set(target, key, value, receiver) {
                if (Reflect.has(target, key)) {
                    return Reflect.set(target, key, value, receiver);
                } else if (Reflect.has(target._data, key)) {
                    return Reflect.set(target._data, key, value, target._data);
                } else {
                    return true;
                }
            },
        });
        // @ts-ignore
        this._create?.call(context);
        if (isNull(options.el)) {
            console.error(`没有节点信息`);
            // @ts-ignore
            return undefined;
        }
        //挂载虚拟dom
        // @ts-ignore
        timer(this.mount.bind(this, options.el, context), "View mount time");
        // create中更新数据，不刷新视图，mounted中数据会刷新视图
        // mounted中是视图挂载
        Vue.dept.$emit(context);
        // @ts-ignore
        this._mounted?.call(context);
        return context;
    }
}

mount(Vue.prototype);

export { Vue as default };
